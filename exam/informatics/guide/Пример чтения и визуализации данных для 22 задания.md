```python
import heapq
from collections import defaultdict, deque


def dfs(graph: defaultdict, start: int = 0):
    visited = set()
    stack = [(start, 0)]

    result = defaultdict()

    while stack:
        vertex, time = stack.pop()

        if vertex not in visited:
            visited.add(vertex)

        # Место для логики. Например, обход всех достижимых вершин или поиск пути (необязательно кратчайшего) и тд
        result[vertex] = time

        for neighbor, weight in graph.get(vertex, []):
            if neighbor not in visited:
                stack.append((neighbor, weight))
    return result


def bfs(graph: defaultdict, start: int = 0):
    visited = set()
    queue = deque([(start, 0)])

    result = defaultdict()

    while queue:
        vertex, time = queue.popleft()

        if vertex not in visited:
            visited.add(vertex)

        # Место для логики. Например, поиск кратчайшего пути между двумя ребрами, поиск всех достижимых вершин
        result[vertex] = time

        for neighbor, weight in graph.get(vertex, []):
            if neighbor not in visited:
                queue.append((neighbor, time + weight))
    return result


def get_max_path_in_graph(graph: defaultdict, start: int = 0):
    in_degree = defaultdict(int)
    all_vertices = set()

    for u in graph:
        all_vertices.add(u)
        for v, w in graph[u]:
            in_degree[v] += 1
            all_vertices.add(v)

    queue = deque(v for v in all_vertices if in_degree[v] == 0)
    topo = []
    while queue:
        u = queue.popleft()
        topo.append(u)
        for v, w in graph.get(u, []):
            in_degree[v] -= 1
            if in_degree[v] == 0:
                queue.append(v)

    dp = defaultdict(lambda: float('-inf'))
    dp[start] = 0

    for u in topo:
        if dp[u] == float('-inf'):
            continue
        for v, w in graph.get(u, []):
            if dp[u] + w > dp[v]:
                dp[v] = dp[u] + w

    return dp


def longest_path(graph, start=0):
    """
    Короткая версия алгоритма
    TODO Нужно проверять и смотреть как работает
    :param graph:
    :param start:
    :return:
    """
    dp = defaultdict(lambda: -10 ** 9)
    dp[start] = 0
    queue = deque([start])
    while queue:
        u = queue.popleft()
        for v, w in graph.get(u, []):
            if dp[u] + w > dp[v]:
                dp[v] = dp[u] + w
                queue.append(v)
    return dp


def dict_to_mermaid(graph_dict, direction="TD", show_weights=True):
    """
    Преобразует defaultdict в формате {from: [(to, weight), ...]} в Mermaid-код.

    Вход:
        graph_dict: defaultdict(list) — ключ: from, значение: список (to, weight)
        direction: "TD" (top-down) или "LR" (left-right)
        show_weights: True — показывать веса на рёбрах, False — без весов

    Выход:
        строка Mermaid-кода
    """
    lines = ["```mermaid", f"graph {direction}"]

    for from_node in graph_dict:
        for to_node, weight in graph_dict[from_node]:
            if show_weights:
                line = f"    {from_node} -->|{weight}| {to_node}"
            else:
                line = f"    {from_node} --> {to_node}"
            lines.append(line)

    lines.append("```")
    return "\n".join(lines)


def main():
    with open('data.txt') as f:
        data = defaultdict(list)
        for row in f.readlines():
            arr_row = row.split()
            b = int(arr_row[0])
            time = int(arr_row[1])
            arr_a = list(map(int, arr_row[2].split(';')))
            for a in arr_a:
                data[a].append((b, time))

    # print(dict_to_mermaid(data))

    result = get_max_path_in_graph(data)
    print(result)
    # print(*sorted(result.items(), key=lambda x: x[1]), sep='\n')


if __name__ == '__main__':
    main()

```


