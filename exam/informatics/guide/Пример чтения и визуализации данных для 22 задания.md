```python
import heapq
from collections import defaultdict, deque


def dfs(graph: defaultdict, start: int = 0):
    visited = set()
    stack = [(start, 0)]

    result = defaultdict()

    while stack:
        vertex, time = stack.pop()

        if vertex not in visited:
            visited.add(vertex)

        # Место для логики. Например, обход всех достижимых вершин или поиск пути (необязательно кратчайшего) и тд
        result[vertex] = time

        for neighbor, weight in graph.get(vertex, []):
            if neighbor not in visited:
                stack.append((neighbor, weight))
    return result


def bfs(graph: defaultdict, start: int = 0):
    visited = set()
    queue = deque([(start, 0)])

    result = defaultdict()

    while queue:
        vertex, time = queue.popleft()

        if vertex not in visited:
            visited.add(vertex)

        # Место для логики. Например, поиск кратчайшего пути между двумя ребрами, поиск всех достижимых вершин
        result[vertex] = time

        for neighbor, weight in graph.get(vertex, []):
            if neighbor not in visited:
                queue.append((neighbor, time + weight))
    return result


def get_max_path_in_graph(graph: defaultdict, start: int = 0):
    # 1. Построение входящих степеней и множества всех вершин
    in_degree = defaultdict(int)
    all_vertices = set()
    for u in graph:
        all_vertices.add(u)
        for v, w in graph[u]:
            in_degree[v] += 1
            all_vertices.add(v)

    # 2. Топологическая сортировка (алгоритм Кахна)
    queue = deque(v for v in all_vertices if in_degree[v] == 0)
    topo = []
    while queue:
        u = queue.popleft()
        topo.append(u)
        for v, w in graph.get(u, []):
            in_degree[v] -= 1
            if in_degree[v] == 0:
                queue.append(v)

    # 3. Инициализация: dp[v] = [предыдущее расстояние, расстояние]
    dp = defaultdict(lambda: [0, float('-inf')])
    dp[start] = [0, 0]  # стартовая вершина — без предшественника, расстояние 0

    # 4. Обновление расстояний в топологическом порядке
    for u in topo:
        for v, w in graph.get(u, []):
            new_dist = dp[u][1] + w
            if new_dist > dp[v][1]:
                dp[v] = [dp[u][1] + 1, new_dist]  # Запоминаем предыдущее расстояние и новое расстояние
    return dp


def dict_to_mermaid(graph_dict, direction="TD", show_weights=True):
    """
    Преобразует defaultdict в формате {from: [(to, weight), ...]} в Mermaid-код.

    Вход:
        graph_dict: defaultdict(list) — ключ: from, значение: список (to, weight)
        direction: "TD" (top-down) или "LR" (left-right)
        show_weights: True — показывать веса на рёбрах, False — без весов

    Выход:
        строка Mermaid-кода
    """
    lines = ["```mermaid", f"graph {direction}"]

    for from_node in graph_dict:
        for to_node, weight in graph_dict[from_node]:
            if show_weights:
                line = f"    {from_node} -->|{weight}| {to_node}"
            else:
                line = f"    {from_node} --> {to_node}"
            lines.append(line)

    lines.append("```")
    return "\n".join(lines)


def main():
    with open('data.txt') as f:
        data = defaultdict(list)
        for row in f.readlines():
            arr_row = row.split()
            b = int(arr_row[0])
            time = int(arr_row[1])
            arr_a = list(map(int, arr_row[2].split(';')))
            for a in arr_a:
                data[a].append((b, time))

    # print(dict_to_mermaid(data))

    result = get_max_path_in_graph(data)
    # print(*result.values(), sep='\n')
    print(*sorted(result.items(), key=lambda x: x[1][0]), sep='\n')


if __name__ == '__main__':
    main()
```
